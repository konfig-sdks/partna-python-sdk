# coding: utf-8

"""
    Coinprofile business API

    Coinprofile business API

    The version of the OpenAPI document: 1.0.0
    Generated by: https://konfigthis.com
"""

from datetime import datetime, date
import typing
from enum import Enum
from typing_extensions import TypedDict, Literal, TYPE_CHECKING
from pydantic import BaseModel, Field, RootModel, ConfigDict


class VoucherRedeemAndWithdrawResponseData(BaseModel):
    # Voucher fee in the outgoing currency
    converted_voucher_fee: typing.Optional[typing.Union[int, float]] = Field(None, alias='convertedVoucherFee')

    # The same as toCurrency
    converted_voucher_fee_currency: typing.Optional[str] = Field(None, alias='convertedVoucherFeeCurrency')

    # Merchant's balance currency
    credit_currency: typing.Optional[str] = Field(None, alias='creditCurrency')

    # Merchant's balance after redeeming voucher
    current_balance: typing.Optional[typing.Union[int, float]] = Field(None, alias='currentBalance')

    # Email that aws used to create the voucher
    email: typing.Optional[str] = Field(None, alias='email')

    # The bearer of voucher fee
    fee_bearer: typing.Optional[Literal["merchant", "client"]] = Field(None, alias='feeBearer')

    # Voucher payment amount.
    from_amount: typing.Optional[typing.Union[int, float]] = Field(None, alias='fromAmount')

    # voucher payment currency
    from_currency: typing.Optional[str] = Field(None, alias='fromCurrency')

    # Voucher ID
    id: typing.Optional[str] = Field(None, alias='id')

    # username of the merchant that created the voucher
    merchant: typing.Optional[str] = Field(None, alias='merchant')

    # This can be optionally provided by the merchant in the request if they want some of the received amount to be added to their Ventogram balance.
    merchant_fee: typing.Optional[typing.Union[int, float]] = Field(None, alias='merchantFee')

    # Merchant's balance before redeeming voucher
    previous_balance: typing.Optional[typing.Union[int, float]] = Field(None, alias='previousBalance')

    # The exchange rate that was used for conversion (if applicable) at the time of redeeming the voucher. If there's no conversion, the value is 1.
    rate: typing.Optional[typing.Union[int, float]] = Field(None, alias='rate')

    # This is basically a unique id
    reference: typing.Optional[str] = Field(None, alias='reference')

    # The crypto wallet address to which asset was transferred
    to_account: typing.Optional[str] = Field(None, alias='toAccount')

    # The amount that was sent to user wallet address.
    to_amount: typing.Optional[typing.Union[int, float]] = Field(None, alias='toAmount')

    # The currency that was sent to user wallet.
    to_currency: typing.Optional[str] = Field(None, alias='toCurrency')

    # Voucher code to be redeemed
    voucher_code: typing.Optional[str] = Field(None, alias='voucherCode')

    # The fee associated with voucher in the payment currency. This will be deducted from merchant's balance if merchant is the fee bearer.
    voucher_fee: typing.Optional[typing.Union[int, float]] = Field(None, alias='voucherFee')

    # The processing fee for the crypto transfer that will be deducted from the merchant's account. Merchants must maintain a sufficient balance to utilize the redeem-and-withdraw endpoint.
    withdrawal_fee: typing.Optional[typing.Union[int, float]] = Field(None, alias='withdrawalFee')

    model_config = ConfigDict(
        protected_namespaces=(),
        arbitrary_types_allowed=True
    )
